1. Получить информацию о всех гномах, которые входят в какой-либо отряд, вместе с информацией об их отрядах. 
Я вывел больше полей с информацией, не все из них переименовывал и не добавлял псевдонимов для таблиц. Но по конструкции и по смыслу совпадает.

2. Найти всех гномов с профессией "miner", которые не состоят ни в одном отряде.


Вместо полей name, age, я выводил поля dward_id и name, кажется они не хуже характеризуют гнома. В остальном, аналогично.

3. Получить все задачи с наивысшим приоритетом, которые находятся в статусе "pending". 
Эталонный запрос.
SELECT 
       task_id,
       description,
       assigned_to
   FROM 
       Tasks
   WHERE 
       priority = (SELECT MAX(priority) FROM Tasks WHERE status = 'pending') 
       AND status = 'pending';
Мой запрос.
SELECT 
task_id, 
description 
FROM 
Tasks 
WHERE 
priority = (SELECT MAX(priority) FROM Tasks) 
AND status = 'pending';

Мой запрос выбирает из всех задач с наивысшим приоритетом, те, которые находятся в статусе ‘pending’, так я понял задачу. Эталонный запрос выбирает из задач которые находятся в статусе ‘pending’, задачи с наивысшим приоритетом. Это более общепринятая трактовка. Впредь постараюсь трактовать также.

4. Для каждого гнома, который владеет хотя бы одним предметом, получить количество предметов, которыми он владеет. 
В целом, аналогично, не считая, что я сделал ошибку, не добавив в GROUP BY поле Dwarves.name.

5. Получить список всех отрядов и количество гномов в каждом отряде. Также включите в выдачу отряды без гномов. 
Мой запрос аналогичен эталонному.


6. Получить список профессий с наибольшим количеством незавершенных задач ("pending" и "in_progress") у гномов этих профессий.
Эталонный запрос выводит список всех профессий у которых есть незавершенных задач в порядке убывания кол-ва задач. Мой запрос выводит список профессий только с наибольшим количеством незавершенных задач. Но из эталонного запроса легко вычленить нужную информацию и при этом он намного легче читается и пишется. Постараюсь запомнить эту хитрость.

7. Для каждого типа предметов узнать средний возраст гномов, владеющих этими предметами.
Эталонный запрос, не учитывает что предметы без владельца, являются общими.
SELECT 
       I.type AS ItemType,
       AVG(D.age) AS AverageAge
   FROM 
       Items I
   JOIN 
       Dwarves D
   ON 
       I.owner_id = D.dwarf_id
   GROUP BY 
       I.type;
Мой запрос это учитывает, но условие в ON становится плохим. Может порождать много лишних строк.
SELECT 
Items.type, 
AVG(Dwarves.age) 
FROM 
Items 
JOIN 
Dwarves 
ON 
(Items.owner_id = Dwarves.dwarf_id OR Items.owner_id IS NULL) 
GROUP BY 
Items.type;
8. Найти всех гномов старше среднего возраста (по всем гномам в базе), которые не владеют никакими предметами. b
Мой запрос аналогичен эталонному, не считая того, что NOT IN может вернуть NULL, а иммено “Обратите внимание, что если левое выражение возвращает null или если нет равных правых значений и хотя бы одна правая строка возвращает null, результатом конструкции NOT IN будет null, а не true. Это соответствует обычным правилам SQL для булевых комбинаций нулевых значений” - перевод Google https://www.postgresql.org/docs/current/functions-subquery.html
Ввиду этого возможно лучше использовать NOT EXIST.
